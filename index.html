<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TAPCHAIN Data Reader - MVP</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .debug-log {
            background-color: #000;
            color: #00ff00;
            padding: 15px;
            border-radius: 5px;
            height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            margin: 20px 0;
        }
        .button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
        }
        .button:hover {
            background-color: #0056b3;
        }
        .button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        .status {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .status.success { background-color: #d4edda; color: #155724; }
        .status.error { background-color: #f8d7da; color: #721c24; }
        .status.warning { background-color: #fff3cd; color: #856404; }
        .chart-container {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîó TAPCHAIN Data Reader - MVP</h1>
        <p>Tap your phone to the TAPCHAIN device to read sensor data via NFC.</p>
        
        <!-- Status Display -->
        <div id="status" class="status info">
            Loading TAPCHAIN Data Reader... Please keep phone close to device.
        </div>
        
        <!-- Control Buttons -->
        <div>
            <button id="checkNfcBtn" class="button">Check NFC Support</button>
            <button id="readNfcBtn" class="button" disabled>Read NFC Data</button>
            <button id="clearLogBtn" class="button">Clear Debug Log</button>
            <button id="testDataBtn" class="button">Test with Mock Data</button>
        </div>
        
        <!-- Debug Console -->
        <h3>üìä Debug Console</h3>
        <div id="debugLog" class="debug-log">
            === TAPCHAIN NFC Reader Debug Console ===<br>
            Waiting for user interaction...<br>
        </div>
        
        <!-- Data Display -->
        <div id="dataDisplay" style="display: none;">
            <h3>üìà Sensor Data</h3>
            <div id="dataTable"></div>
        </div>
        
        <!-- Chart Area -->
        <div id="chartContainer" class="chart-container" style="display: none;">
            <h3>üìâ Charts</h3>
            <canvas id="chart" width="400" height="200"></canvas>
        </div>
    </div>

    <!-- Chart.js Library -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <script>
        // Global variables for debugging
        let debugLog = document.getElementById('debugLog');
        let statusDiv = document.getElementById('status');
        let lastReadData = null;
        
        // Debug logging function
        function log(message, type = 'info') {
            const timestamp = new Date().toISOString().split('T')[1].slice(0, 8);
            const prefix = type === 'error' ? '‚ùå' : type === 'success' ? '‚úÖ' : type === 'warning' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è';
            debugLog.innerHTML += `[${timestamp}] ${prefix} ${message}<br>`;
            debugLog.scrollTop = debugLog.scrollHeight;
            console.log(`[TAPCHAIN] ${message}`);
        }
        
        // Update status display
        function updateStatus(message, type) {
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
        }
        
        // Check if browser supports Web NFC
        function checkNfcSupport() {
            log('Checking Web NFC API support...');
            
            if ('NDEFReader' in window) {
                log('‚úÖ Web NFC API is supported!', 'success');
                updateStatus('Web NFC is supported! You can now read NFC data.', 'success');
                document.getElementById('readNfcBtn').disabled = false;
                return true;
            } else {
                log('‚ùå Web NFC API is NOT supported in this browser', 'error');
                updateStatus('Web NFC not supported. Use Chrome on Android or enable experimental features.', 'error');
                log('üí° Try: Chrome on Android, or Chrome with --enable-experimental-web-platform-features flag', 'warning');
                return false;
            }
        }
        
        // Global variables for continuous download
        let continuousDownload = {
            active: false,
            packets: [],
            totalPackets: 0,
            allReadings: []
        };
        
        // Read NFC data function with continuous packet support
        async function readNfcData() {
            if (!('NDEFReader' in window)) {
                log('‚ùå Web NFC not supported', 'error');
                return;
            }
            
            try {
                log('üîç Automatically starting NFC scan...');
                updateStatus('üì± Scanning for device data - keep phone close!', 'warning');
                
                // Reset download state
                continuousDownload = {
                    active: true,
                    packets: [],
                    totalPackets: 0,
                    allReadings: []
                };
                
                const ndef = new NDEFReader();
                await ndef.scan();
                
                log('üì° NFC scan active - waiting for device data...');
                log('üí° If no data appears, try tapping the device again');
                
                ndef.addEventListener("reading", ({ message, serialNumber }) => {
                    if (!continuousDownload.active) return;
                    
                    log(`üì¶ Packet received from device ${serialNumber}`);
                    
                    // Process each NDEF record
                    for (const record of message.records) {
                        if (record.recordType === "text") {
                            const textDecoder = new TextDecoder(record.encoding);
                            const text = textDecoder.decode(record.data);
                            log(`üìÑ Text content: ${text}`);
                        } else if (record.recordType === "url") {
                            const textDecoder = new TextDecoder();
                            const url = textDecoder.decode(record.data);
                            log(`üîó URL content: ${url}`);
                        } else {
                            // Process continuous packet data
                            const packetData = processNDEFContinuousPacket(record.data);
                            if (packetData) {
                                handleContinuousPacket(packetData);
                            }
                        }
                    }
                });
                
                ndef.addEventListener("readingerror", () => {
                    log('‚ùå Error reading NFC tag', 'error');
                    if (continuousDownload.active) {
                        updateStatus('Download interrupted. Try again.', 'error');
                        continuousDownload.active = false;
                    }
                });
                
                // Timeout for continuous download
                setTimeout(() => {
                    if (continuousDownload.active) {
                        finalizeContinuousDownload();
                    }
                }, 10000); // 10 second timeout
                
            } catch (error) {
                log(`‚ùå NFC scan failed: ${error}`, 'error');
                updateStatus(`NFC scan failed: ${error.message}`, 'error');
                continuousDownload.active = false;
            }
        }
        
        // Process individual continuous packet
        function processNDEFContinuousPacket(dataBuffer) {
            try {
                const data = new Uint8Array(dataBuffer);
                log(`üìä Processing packet (${data.length} bytes)`);
                
                if (data.length < 16) {
                    log('‚ùå Packet too short', 'error');
                    return null;
                }
                
                // Parse NDEF TLV and find TAPCHAIN signature
                let offset = 0;
                while (offset < data.length - 3) {
                    if (data[offset] === 0x03) break;
                    offset++;
                }
                
                if (offset >= data.length - 3) return null;
                
                // Skip TLV header
                offset++;
                if (data[offset] === 0xFF) {
                    offset += 3;
                } else {
                    offset++;
                }
                
                // Find TAPCHAIN signature
                let dataStart = -1;
                for (let i = offset; i < offset + 20 && i < data.length - 1; i++) {
                    if (data[i] === 0x54 && data[i + 1] === 0x43) {
                        dataStart = i + 2;
                        break;
                    }
                }
                
                if (dataStart === -1) return null;
                
                offset = dataStart;
                const count = data[offset];
                const interval = data[offset + 1];
                const version = data[offset + 2];
                const currentPacket = (data[offset + 3] << 8) | data[offset + 4];
                const totalPackets = (data[offset + 5] << 8) | data[offset + 6];
                
                offset += 7;
                
                // Parse readings
                const readings = [];
                for (let i = 0; i < count && offset + 6 <= data.length; i++) {
                    const tempRaw = (data[offset] << 8) | data[offset + 1];
                    const temperature = (tempRaw > 32767 ? tempRaw - 65536 : tempRaw) / 10.0;
                    const humidityRaw = (data[offset + 2] << 8) | data[offset + 3];
                    const humidity = humidityRaw / 10.0;
                    const lightState = data[offset + 4];
                    const checksum = data[offset + 5];
                    
                    readings.push({
                        temperature,
                        humidity,
                        lightState,
                        checksum
                    });
                    
                    offset += 6;
                }
                
                return {
                    currentPacket,
                    totalPackets,
                    count,
                    interval,
                    version,
                    readings
                };
                
            } catch (error) {
                log(`‚ùå Error processing packet: ${error}`, 'error');
                return null;
            }
        }
        
        // Handle continuous packet reception
        function handleContinuousPacket(packetData) {
            const { currentPacket, totalPackets, readings } = packetData;
            
            // Store packet
            continuousDownload.packets[currentPacket - 1] = packetData;
            continuousDownload.totalPackets = totalPackets;
            
            // Add readings to combined array
            continuousDownload.allReadings.push(...readings);
            
            const receivedPackets = continuousDownload.packets.filter(p => p !== undefined).length;
            const progressPercent = Math.round((receivedPackets / totalPackets) * 100);
            
            log(`üì¶ Packet ${currentPacket}/${totalPackets} received (${readings.length} readings)`);
            updateStatus(`Downloading... ${progressPercent}% (${receivedPackets}/${totalPackets} packets)`, 'warning');
            
            // Check if download is complete
            if (receivedPackets === totalPackets) {
                finalizeContinuousDownload();
            }
        }
        
        // Finalize continuous download
        function finalizeContinuousDownload() {
            continuousDownload.active = false;
            
            const totalReadings = continuousDownload.allReadings.length;
            log(`‚úÖ Download complete! Received ${totalReadings} readings in ${continuousDownload.packets.length} packets`);
            
            if (totalReadings > 0) {
                // Create combined dataset
                lastReadData = {
                    count: totalReadings,
                    interval: continuousDownload.packets[0]?.interval || 10,
                    version: continuousDownload.packets[0]?.version || 3,
                    readings: continuousDownload.allReadings,
                    timestamp: new Date()
                };
                
                updateStatus(`Download complete! ${totalReadings} readings (60 days) downloaded successfully`, 'success');
                displayData(lastReadData);
                createChart(lastReadData);
            } else {
                updateStatus('Download failed - no data received', 'error');
            }
        }
        
        // Process NDEF binary sensor data from TAPCHAIN device
        function processNDEFSensorData(dataBuffer) {
            try {
                log('üîç Parsing NDEF sensor data buffer...');
                const data = new Uint8Array(dataBuffer);
                log(`üìä Raw NDEF data (${data.length} bytes): ${Array.from(data).map(b => b.toString(16).padStart(2, '0')).join(' ')}`);
                
                if (data.length < 12) {
                    log('‚ùå Data too short for valid NDEF sensor data', 'error');
                    return;
                }
                
                // Parse NDEF TLV structure
                let offset = 0;
                
                // Find NDEF message TLV (0x03)
                while (offset < data.length - 3) {
                    if (data[offset] === 0x03) {
                        log('üìÑ Found NDEF Message TLV');
                        break;
                    }
                    offset++;
                }
                
                if (offset >= data.length - 3) {
                    log('‚ùå No NDEF Message TLV found', 'error');
                    return;
                }
                
                // Parse TLV length (can be 1 or 3 bytes)
                offset++; // Skip TLV type
                let tlv_length;
                if (data[offset] === 0xFF) {
                    // 3-byte length
                    tlv_length = (data[offset + 1] << 8) | data[offset + 2];
                    offset += 3;
                } else {
                    // 1-byte length
                    tlv_length = data[offset];
                    offset++;
                }
                
                log(`üìè NDEF message length: ${tlv_length} bytes`);
                
                // Skip NDEF record header (look for our custom header)
                // Look for our TAPCHAIN signature "TC"
                let dataStart = -1;
                for (let i = offset; i < offset + 20 && i < data.length - 1; i++) {
                    if (data[i] === 0x54 && data[i + 1] === 0x43) { // "TC"
                        dataStart = i + 2;
                        log('üéØ Found TAPCHAIN data signature');
                        break;
                    }
                }
                
                if (dataStart === -1) {
                    log('‚ùå TAPCHAIN signature not found', 'error');
                    return;
                }
                
                // Parse TAPCHAIN header
                offset = dataStart;
                const count = data[offset];
                const interval = data[offset + 1];
                const version = data[offset + 2];
                
                log(`üìà Sensor readings: ${count} samples`);
                log(`‚è±Ô∏è Collection interval: ${interval} minutes`);
                log(`üè∑Ô∏è Data format version: ${version}`);
                
                offset += 3; // Skip header
                
                // Parse sensor readings (6 bytes each: temp(2) + humidity(2) + light(1) + checksum(1))
                const readings = [];
                const bytesPerReading = 6;
                
                for (let i = 0; i < count && offset + bytesPerReading <= data.length; i++) {
                    // Parse temperature (2 bytes, signed, *10)
                    const tempRaw = (data[offset] << 8) | data[offset + 1];
                    const temperature = (tempRaw > 32767 ? tempRaw - 65536 : tempRaw) / 10.0;
                    
                    // Parse humidity (2 bytes, *10)
                    const humidityRaw = (data[offset + 2] << 8) | data[offset + 3];
                    const humidity = humidityRaw / 10.0;
                    
                    // Parse light state (1 byte)
                    const lightState = data[offset + 4];
                    
                    // Parse checksum (1 byte)
                    const checksum = data[offset + 5];
                    
                    readings.push({
                        index: i,
                        temperature: temperature,
                        humidity: humidity,
                        lightState: lightState,
                        checksum: checksum
                    });
                    
                    log(`üìä Reading ${i + 1}: ${temperature}¬∞C, ${humidity}%, Light: ${lightState ? 'ON' : 'OFF'}, CRC: 0x${checksum.toString(16)}`);
                    
                    offset += bytesPerReading;
                }
                
                lastReadData = {
                    count: count,
                    interval: interval,
                    version: version,
                    readings: readings,
                    timestamp: new Date()
                };
                
                displayData(lastReadData);
                createChart(lastReadData);
                
            } catch (error) {
                log(`‚ùå Error processing NDEF sensor data: ${error}`, 'error');
            }
        }
        
        // Legacy function for old SRAM format (keep for compatibility)
        function processSensorData(dataBuffer) {
            try {
                log('üîç Parsing legacy sensor data buffer...');
                const data = new Uint8Array(dataBuffer);
                log(`üìä Raw data (${data.length} bytes): ${Array.from(data).map(b => b.toString(16).padStart(2, '0')).join(' ')}`);
                
                if (data.length < 2) {
                    log('‚ùå Data too short for valid sensor data', 'error');
                    return;
                }
                
                const count = data[0];
                const interval = data[1];
                
                log(`üìà Sensor readings: ${count} samples`);
                log(`‚è±Ô∏è Collection interval: ${interval} minutes`);
                
                const readings = [];
                const bytesPerReading = 4; // 2 bytes temp + 1 byte humidity + 1 byte light
                
                for (let i = 0; i < count && (2 + i * bytesPerReading + 3) < data.length; i++) {
                    const offset = 2 + i * bytesPerReading;
                    
                    // Parse temperature (2 bytes, signed, *10)
                    const tempRaw = (data[offset] << 8) | data[offset + 1];
                    const temperature = (tempRaw > 32767 ? tempRaw - 65536 : tempRaw) / 10.0;
                    
                    // Parse humidity (1 byte, *10 but only low byte stored)
                    const humidity = data[offset + 2] / 10.0;
                    
                    // Parse light state (1 byte)
                    const lightState = data[offset + 3];
                    
                    readings.push({
                        index: i,
                        temperature: temperature,
                        humidity: humidity,
                        lightState: lightState
                    });
                    
                    log(`üìä Reading ${i + 1}: ${temperature}¬∞C, ${humidity}%, Light: ${lightState ? 'ON' : 'OFF'}`);
                }
                
                lastReadData = {
                    count: count,
                    interval: interval,
                    readings: readings,
                    timestamp: new Date()
                };
                
                displayData(lastReadData);
                createChart(lastReadData);
                
            } catch (error) {
                log(`‚ùå Error processing sensor data: ${error}`, 'error');
            }
        }
        
        // Display data in table format
        function displayData(data) {
            const dataDisplay = document.getElementById('dataDisplay');
            const dataTable = document.getElementById('dataTable');
            
            let html = `
                <p><strong>Total Readings:</strong> ${data.count}</p>
                <p><strong>Collection Interval:</strong> ${data.interval} minutes</p>
                <p><strong>Read Time:</strong> ${data.timestamp.toLocaleString()}</p>
                <table style="width: 100%; border-collapse: collapse; margin-top: 10px;">
                    <thead>
                        <tr style="background-color: #f8f9fa;">
                            <th style="border: 1px solid #ddd; padding: 8px;">Reading #</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">Temperature (¬∞C)</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">Humidity (%)</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">Light</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            data.readings.forEach((reading, index) => {
                html += `
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px; text-align: center;">${index + 1}</td>
                        <td style="border: 1px solid #ddd; padding: 8px; text-align: center;">${reading.temperature.toFixed(1)}</td>
                        <td style="border: 1px solid #ddd; padding: 8px; text-align: center;">${reading.humidity.toFixed(1)}</td>
                        <td style="border: 1px solid #ddd; padding: 8px; text-align: center;">${reading.lightState ? 'ON' : 'OFF'}</td>
                    </tr>
                `;
            });
            
            html += '</tbody></table>';
            dataTable.innerHTML = html;
            dataDisplay.style.display = 'block';
        }
        
        // Create chart visualization
        function createChart(data) {
            const chartContainer = document.getElementById('chartContainer');
            const ctx = document.getElementById('chart').getContext('2d');
            
            // Calculate timestamps (working backwards from now)
            const now = data.timestamp;
            const timestamps = data.readings.map((_, index) => {
                const minutesAgo = (data.readings.length - 1 - index) * data.interval;
                return new Date(now.getTime() - minutesAgo * 60000);
            });
            
            // Clear existing chart
            if (window.myChart) {
                window.myChart.destroy();
            }
            
            window.myChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: timestamps.map(t => t.toLocaleTimeString()),
                    datasets: [{
                        label: 'Temperature (¬∞C)',
                        data: data.readings.map(r => r.temperature),
                        borderColor: 'rgb(255, 99, 132)',
                        backgroundColor: 'rgba(255, 99, 132, 0.2)',
                        yAxisID: 'y'
                    }, {
                        label: 'Humidity (%)',
                        data: data.readings.map(r => r.humidity),
                        borderColor: 'rgb(54, 162, 235)',
                        backgroundColor: 'rgba(54, 162, 235, 0.2)',
                        yAxisID: 'y1'
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Temperature (¬∞C)'
                            }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Humidity (%)'
                            },
                            grid: {
                                drawOnChartArea: false,
                            },
                        }
                    }
                }
            });
            
            chartContainer.style.display = 'block';
            log('üìà Chart created successfully!', 'success');
        }
        
        // Test with mock data
        function testWithMockData() {
            log('üß™ Generating mock NDEF sensor data for testing...');
            
            // Create mock NDEF binary data that matches our new device format
            const mockData = new Uint8Array(50);
            let offset = 0;
            
            // NDEF TLV header
            mockData[offset++] = 0x03; // NDEF Message TLV
            mockData[offset++] = 0x2C; // Length = 44 bytes (5 readings * 6 bytes + 14 byte header)
            
            // NDEF Record header (simplified)
            mockData[offset++] = 0xC1; // Record header
            mockData[offset++] = 0x01; // Type length
            mockData[offset++] = 0x29; // Payload length = 41 bytes
            mockData[offset++] = 0x54; // Type = 'T'
            
            // TAPCHAIN signature and header
            mockData[offset++] = 0x54; // 'T'
            mockData[offset++] = 0x43; // 'C'
            mockData[offset++] = 5;    // 5 readings
            mockData[offset++] = 1;    // 1 minute interval
            mockData[offset++] = 1;    // Version 1
            
            // Add 5 mock readings (6 bytes each)
            for (let i = 0; i < 5; i++) {
                // Temperature: 25.5¬∞C + i = 255 + i*10 (stored as int16 * 10)
                const temp = 255 + i * 10;
                mockData[offset++] = (temp >> 8) & 0xFF;
                mockData[offset++] = temp & 0xFF;
                
                // Humidity: 60.0% + i*5 = 600 + i*50 (stored as uint16 * 10)
                const humidity = 600 + i * 50;
                mockData[offset++] = (humidity >> 8) & 0xFF;
                mockData[offset++] = humidity & 0xFF;
                
                // Light state: alternating
                mockData[offset++] = i % 2;
                
                // Checksum (mock)
                mockData[offset++] = 0xAA + i;
            }
            
            log('üî¢ Mock NDEF data created, processing...');
            processNDEFSensorData(mockData.buffer);
        }
        
        // Event listeners
        document.getElementById('checkNfcBtn').addEventListener('click', checkNfcSupport);
        document.getElementById('readNfcBtn').addEventListener('click', readNfcData);
        document.getElementById('clearLogBtn').addEventListener('click', () => {
            debugLog.innerHTML = '=== Debug Log Cleared ===<br>';
        });
        document.getElementById('testDataBtn').addEventListener('click', testWithMockData);
        
        // Auto-start NFC reading when page loads
        async function autoStartNFC() {
            log('üöÄ TAPCHAIN NFC Reader loaded');
            
            // Check if Web NFC is supported
            if (!('NDEFReader' in window)) {
                log('‚ùå Web NFC not supported on this device', 'error');
                updateStatus('NFC not supported', 'error');
                return;
            }
            
            log('üì± NFC supported - starting automatic scan...', 'success');
            updateStatus('Automatically scanning for NFC data...', 'info');
            
            // Automatically start reading NFC data
            setTimeout(() => {
                readNfcData();
                
                // Show manual options after 10 seconds if no data received
                setTimeout(() => {
                    if (continuousDownload && !continuousDownload.packets.length) {
                        log('‚è∞ No data detected yet - manual controls available below');
                        updateStatus('Tap device again or use manual controls below', 'info');
                    }
                }, 10000);
            }, 1000); // Small delay to let the page fully load
        }
        
        // Initialize automatically
        window.addEventListener('DOMContentLoaded', autoStartNFC);
    </script>
</body>
</html>
