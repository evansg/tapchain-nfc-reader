<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TAPCHAIN Data Reader - MVP</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .debug-log {
            background-color: #000;
            color: #00ff00;
            padding: 15px;
            border-radius: 5px;
            height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            margin: 20px 0;
        }
        .button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
        }
        .button:hover {
            background-color: #0056b3;
        }
        .button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        .status {
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
        }
        .status.success { background-color: #d4edda; color: #155724; }
        .status.error { background-color: #f8d7da; color: #721c24; }
        .status.warning { background-color: #fff3cd; color: #856404; }
        .chart-container {
            margin: 20px 0;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîó TAPCHAIN Data Reader - MVP</h1>
        <p>Tap your phone to the TAPCHAIN device to read sensor data via NFC.</p>
        
        <!-- Status Display -->
        <div id="status" class="status warning">
            Ready to read NFC data. Click "Check NFC Support" to start.
        </div>
        
        <!-- Control Buttons -->
        <div>
            <button id="checkNfcBtn" class="button">Check NFC Support</button>
            <button id="readNfcBtn" class="button" disabled>Read NFC Data</button>
            <button id="clearLogBtn" class="button">Clear Debug Log</button>
            <button id="testDataBtn" class="button">Test with Mock Data</button>
        </div>
        
        <!-- Debug Console -->
        <h3>üìä Debug Console</h3>
        <div id="debugLog" class="debug-log">
            === TAPCHAIN NFC Reader Debug Console ===<br>
            Waiting for user interaction...<br>
        </div>
        
        <!-- Data Display -->
        <div id="dataDisplay" style="display: none;">
            <h3>üìà Sensor Data</h3>
            <div id="dataTable"></div>
        </div>
        
        <!-- Chart Area -->
        <div id="chartContainer" class="chart-container" style="display: none;">
            <h3>üìâ Charts</h3>
            <canvas id="chart" width="400" height="200"></canvas>
        </div>
    </div>

    <!-- Chart.js Library -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <script>
        // Global variables for debugging
        let debugLog = document.getElementById('debugLog');
        let statusDiv = document.getElementById('status');
        let lastReadData = null;
        
        // Debug logging function
        function log(message, type = 'info') {
            const timestamp = new Date().toISOString().split('T')[1].slice(0, 8);
            const prefix = type === 'error' ? '‚ùå' : type === 'success' ? '‚úÖ' : type === 'warning' ? '‚ö†Ô∏è' : '‚ÑπÔ∏è';
            debugLog.innerHTML += `[${timestamp}] ${prefix} ${message}<br>`;
            debugLog.scrollTop = debugLog.scrollHeight;
            console.log(`[TAPCHAIN] ${message}`);
        }
        
        // Update status display
        function updateStatus(message, type) {
            statusDiv.textContent = message;
            statusDiv.className = `status ${type}`;
        }
        
        // Check if browser supports Web NFC
        function checkNfcSupport() {
            log('Checking Web NFC API support...');
            
            if ('NDEFReader' in window) {
                log('‚úÖ Web NFC API is supported!', 'success');
                updateStatus('Web NFC is supported! You can now read NFC data.', 'success');
                document.getElementById('readNfcBtn').disabled = false;
                return true;
            } else {
                log('‚ùå Web NFC API is NOT supported in this browser', 'error');
                updateStatus('Web NFC not supported. Use Chrome on Android or enable experimental features.', 'error');
                log('üí° Try: Chrome on Android, or Chrome with --enable-experimental-web-platform-features flag', 'warning');
                return false;
            }
        }
        
        // Read NFC data function
        async function readNfcData() {
            if (!('NDEFReader' in window)) {
                log('‚ùå Web NFC not supported', 'error');
                return;
            }
            
            try {
                log('üîç Starting NFC scan...');
                updateStatus('Scanning for NFC tag... Bring your phone close to the TAPCHAIN device.', 'warning');
                
                const ndef = new NDEFReader();
                await ndef.scan();
                
                log('üì° NFC scan started successfully');
                log('üëÜ Please tap your phone to the TAPCHAIN device now');
                
                ndef.addEventListener("reading", ({ message, serialNumber }) => {
                    log(`üìñ NFC tag detected! Serial: ${serialNumber}`);
                    log(`üìÑ Message contains ${message.records.length} record(s)`);
                    
                    // Process each NDEF record
                    for (const record of message.records) {
                        log(`üìù Record type: ${record.recordType}`);
                        log(`üíæ Record data length: ${record.data.byteLength} bytes`);
                        
                        if (record.recordType === "text") {
                            const textDecoder = new TextDecoder(record.encoding);
                            const text = textDecoder.decode(record.data);
                            log(`üìÑ Text content: ${text}`);
                        } else if (record.recordType === "url") {
                            const textDecoder = new TextDecoder();
                            const url = textDecoder.decode(record.data);
                            log(`üîó URL content: ${url}`);
                        } else {
                            // Raw binary data (this is what we expect from TAPCHAIN)
                            log('üî¢ Processing binary sensor data...');
                            processSensorData(record.data);
                        }
                    }
                    
                    updateStatus('NFC data read successfully!', 'success');
                });
                
                ndef.addEventListener("readingerror", () => {
                    log('‚ùå Error reading NFC tag', 'error');
                    updateStatus('Error reading NFC tag. Try again.', 'error');
                });
                
            } catch (error) {
                log(`‚ùå NFC scan failed: ${error}`, 'error');
                updateStatus(`NFC scan failed: ${error.message}`, 'error');
            }
        }
        
        // Process sensor data from NFC
        function processSensorData(dataBuffer) {
            try {
                log('üîç Parsing sensor data buffer...');
                const data = new Uint8Array(dataBuffer);
                log(`üìä Raw data (${data.length} bytes): ${Array.from(data).map(b => b.toString(16).padStart(2, '0')).join(' ')}`);
                
                if (data.length < 2) {
                    log('‚ùå Data too short for valid sensor data', 'error');
                    return;
                }
                
                const count = data[0];
                const interval = data[1];
                
                log(`üìà Sensor readings: ${count} samples`);
                log(`‚è±Ô∏è Collection interval: ${interval} minutes`);
                
                const readings = [];
                const bytesPerReading = 4; // 2 bytes temp + 1 byte humidity + 1 byte light
                
                for (let i = 0; i < count && (2 + i * bytesPerReading + 3) < data.length; i++) {
                    const offset = 2 + i * bytesPerReading;
                    
                    // Parse temperature (2 bytes, signed, *10)
                    const tempRaw = (data[offset] << 8) | data[offset + 1];
                    const temperature = (tempRaw > 32767 ? tempRaw - 65536 : tempRaw) / 10.0;
                    
                    // Parse humidity (1 byte, *10 but only low byte stored)
                    const humidity = data[offset + 2] / 10.0;
                    
                    // Parse light state (1 byte)
                    const lightState = data[offset + 3];
                    
                    readings.push({
                        index: i,
                        temperature: temperature,
                        humidity: humidity,
                        lightState: lightState
                    });
                    
                    log(`üìä Reading ${i + 1}: ${temperature}¬∞C, ${humidity}%, Light: ${lightState ? 'ON' : 'OFF'}`);
                }
                
                lastReadData = {
                    count: count,
                    interval: interval,
                    readings: readings,
                    timestamp: new Date()
                };
                
                displayData(lastReadData);
                createChart(lastReadData);
                
            } catch (error) {
                log(`‚ùå Error processing sensor data: ${error}`, 'error');
            }
        }
        
        // Display data in table format
        function displayData(data) {
            const dataDisplay = document.getElementById('dataDisplay');
            const dataTable = document.getElementById('dataTable');
            
            let html = `
                <p><strong>Total Readings:</strong> ${data.count}</p>
                <p><strong>Collection Interval:</strong> ${data.interval} minutes</p>
                <p><strong>Read Time:</strong> ${data.timestamp.toLocaleString()}</p>
                <table style="width: 100%; border-collapse: collapse; margin-top: 10px;">
                    <thead>
                        <tr style="background-color: #f8f9fa;">
                            <th style="border: 1px solid #ddd; padding: 8px;">Reading #</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">Temperature (¬∞C)</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">Humidity (%)</th>
                            <th style="border: 1px solid #ddd; padding: 8px;">Light</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            data.readings.forEach((reading, index) => {
                html += `
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 8px; text-align: center;">${index + 1}</td>
                        <td style="border: 1px solid #ddd; padding: 8px; text-align: center;">${reading.temperature.toFixed(1)}</td>
                        <td style="border: 1px solid #ddd; padding: 8px; text-align: center;">${reading.humidity.toFixed(1)}</td>
                        <td style="border: 1px solid #ddd; padding: 8px; text-align: center;">${reading.lightState ? 'ON' : 'OFF'}</td>
                    </tr>
                `;
            });
            
            html += '</tbody></table>';
            dataTable.innerHTML = html;
            dataDisplay.style.display = 'block';
        }
        
        // Create chart visualization
        function createChart(data) {
            const chartContainer = document.getElementById('chartContainer');
            const ctx = document.getElementById('chart').getContext('2d');
            
            // Calculate timestamps (working backwards from now)
            const now = data.timestamp;
            const timestamps = data.readings.map((_, index) => {
                const minutesAgo = (data.readings.length - 1 - index) * data.interval;
                return new Date(now.getTime() - minutesAgo * 60000);
            });
            
            // Clear existing chart
            if (window.myChart) {
                window.myChart.destroy();
            }
            
            window.myChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: timestamps.map(t => t.toLocaleTimeString()),
                    datasets: [{
                        label: 'Temperature (¬∞C)',
                        data: data.readings.map(r => r.temperature),
                        borderColor: 'rgb(255, 99, 132)',
                        backgroundColor: 'rgba(255, 99, 132, 0.2)',
                        yAxisID: 'y'
                    }, {
                        label: 'Humidity (%)',
                        data: data.readings.map(r => r.humidity),
                        borderColor: 'rgb(54, 162, 235)',
                        backgroundColor: 'rgba(54, 162, 235, 0.2)',
                        yAxisID: 'y1'
                    }]
                },
                options: {
                    responsive: true,
                    scales: {
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Temperature (¬∞C)'
                            }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Humidity (%)'
                            },
                            grid: {
                                drawOnChartArea: false,
                            },
                        }
                    }
                }
            });
            
            chartContainer.style.display = 'block';
            log('üìà Chart created successfully!', 'success');
        }
        
        // Test with mock data
        function testWithMockData() {
            log('üß™ Generating mock sensor data for testing...');
            
            // Create mock binary data that matches our device format
            const mockData = new Uint8Array(32);
            mockData[0] = 5;  // 5 readings
            mockData[1] = 1;  // 1 minute interval
            
            // Add 5 mock readings
            for (let i = 0; i < 5; i++) {
                const offset = 2 + i * 4;
                // Temperature: 25.5¬∞C = 255 (stored as int16 * 10)
                const temp = 255 + i * 10;
                mockData[offset] = (temp >> 8) & 0xFF;
                mockData[offset + 1] = temp & 0xFF;
                // Humidity: 60.0% = 60 (stored as low byte only)
                mockData[offset + 2] = 60 + i * 5;
                // Light state: alternating
                mockData[offset + 3] = i % 2;
            }
            
            log('üî¢ Mock data created, processing...');
            processSensorData(mockData.buffer);
        }
        
        // Event listeners
        document.getElementById('checkNfcBtn').addEventListener('click', checkNfcSupport);
        document.getElementById('readNfcBtn').addEventListener('click', readNfcData);
        document.getElementById('clearLogBtn').addEventListener('click', () => {
            debugLog.innerHTML = '=== Debug Log Cleared ===<br>';
        });
        document.getElementById('testDataBtn').addEventListener('click', testWithMockData);
        
        // Initialize
        log('üöÄ TAPCHAIN NFC Reader loaded');
        log('üí° Click "Check NFC Support" to begin');
    </script>
</body>
</html>